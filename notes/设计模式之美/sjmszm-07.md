# 设计模式与范式：结构型

**单例模式**：创建**全局唯一的对象**。

**工厂模式**：创建不同但是**相关类型的对象**（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。

**建造者模式**：创建**复杂对象**，可以通过设置不同的可选参数，“定制化”地创建不同的对象。

**原型模式**：针对**创建成本比较大的对象**，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

**结构型模式**主要总结了一些**类或对象组合**在一起的经典结构，这些经典的结构可以解决**特定应用场景**的问题。包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。



## 48-代理模式：代理在RPC、缓存、监控等场景中的应用

### 代理模式的原理解析



### 动态代理的原理解析



### 代理模式的应用场景



#### 1. 业务系统的非功能性需求开发

监控、统计、鉴权、限流、事务、幂等、日志。

#### 2. 代理模式在 RPC、缓存中的应用



## 49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？

### 桥接模式的原理解析

> Bridge Design Pattern, "Decouple an abstraction from its implementation so that the two can vary independently。"
>
> “将抽象和实现解耦，让它们可以独立变化。”

“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”



## 50-装饰器模式：通过剖析Java IO类库源码学习装饰器模式



装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。



## 51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？

这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。

但这四种模式**解决的问题、应用场景**不同。

代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。



## 52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？



## 53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？





## 54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？



## 55-享元模式（下）：剖析享元模式在Java Integer、String中的应用

