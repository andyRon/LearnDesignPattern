

## 10-理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？

继承最大的问题就在于：**继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性**。





## 11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？

领域驱动设计（Domain Driven Design，简称 DDD）



### 什么是基于贫血模型的传统开发模式？

只包含数据，不包含业务逻辑的类，就叫作**贫血模型**（Anemic Domain Model）。



### 什么是基于充血模型的 DDD 开发模式？

**充血模型**（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。



#### 什么是领域驱动设计？

主要是用来指导**如何解耦业务系统，划分业务模块，定义业务领域模型及其交互**。

**微服务**



### 为什么基于贫血模型的传统开发模式如此受欢迎？



### 什么项目应该考虑使用基于充血模型的 DDD 开发模式？





## 12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？

??



## 13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？



“如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间该如何交互？如何组装类成一个可执行的程序？”



## 14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？

### 如何进行面向对象设计？

#### 1. 划分职责进而识别出有哪些类

类是现实世界中事物的一个<font color=#FF8C00>**建模**</font>。不是每个需求都能映射到现实世界，不是每个类都与现实世界中的事物一一对应。

把需求描述中的**名词**罗列出来，作为可能的候选类，然后再进行筛选。

根据需求描述，把其中涉及的**功能点**，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。

#### 2. 定义类及其属性和方法



#### 3. 定义类与类之间的交互关系



#### 4. 将类组装起来并提供执行入口



### 如何进行面向对象编程？



# 设计原则与思想：设计原则



## 15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？



### 如何理解单一职责原则（SRP）？

一个类只负责完成一个职责或者功能。不要设计大而全的类，要**设计粒度小、功能单一**的类。

单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

### 如何判断类的职责是否足够单一？

不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些**侧面的判断指标**更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：

- 类中的代码行数、函数或者属性过多；
- 类依赖的其他类过多，或者依赖类的其他类过多；
- 私有方法过多；
- 比较难给类起一个合适的名字；
- 类中大量的方法都是集中操作类中的某几个属性。

### 类的职责是否设计得越单一越好？



## 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？



## 17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？

里式替换原则是用来指导，**继承关系中子类该如何设计**的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。



## 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？





## 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？



### 控制反转（IOC）

Inversion Of Control，“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

### 依赖注入（DI）

Dependency Injection，不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。



### 依赖注入框架（DI Framework）



### 依赖反转原则（DIP）

Dependency Inversion Principle，也称依赖倒置原则

> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。



## 20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？

### 如何理解“KISS 原则”？

**尽量保持简单**，英文有几个版本：

- Keep It Simple and Stupid.
- Keep It Short and Simple.
- Keep It Simple and Straightforward.

KISS原则应用很多场景：软件开发、系统设计、产品设计等。

### 代码行数越少就越“简单”吗？



### 代码逻辑复杂就违背 KISS 原则吗？



### 如何写出满足 KISS 原则的代码？

越是能用简单的方法解决复杂的问题，越能体现一个人的能力。

### YAGNI 跟 KISS 说的是一回事吗？

YAGNI，You Ain’t Gonna Need It，直译”**你不会需要它**“。应用到软件开发中就是：”**不要去设计当前用不到的功能；不要去编写当前用不到的代码。**“



## 21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？



### DRY 原则（Don’t Repeat Yourself）

三种典型的代码重复情况：**逻辑重复、功能语义重复和代码执行重复**。



### 代码复用性（Code Reusability）



## 22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？



### 何为“高内聚、松耦合”？

“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如**系统、模块、类，甚至是函数**，也可以应用到不同的开发场景中，比如**微服务、框架、组件、类库**等。

**高内聚**，就是指<font color=#FF8C00>**相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中**</font>。

**松耦合**，就是指<font color=#FF8C00>**类与类之间的依赖关系简单清晰**</font>。



### “迪米特法则”理论描述



## 23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？

对于一个工程师来说，如果要追求长远发展，你就不能一直只把自己放在执行者的角色，不能只是一个**代码实现者**，你还要有独立负责一个系统的能力，**能端到端（end to end）开发一个完整的系统**。这其中的工作就包括：**前期的需求沟通分析**、**中期的代码设计实现**、**后期的系统上线维护**等。

积分兑换系统



## 24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？



### 业务开发包括哪些工作？

**接口设计**、**数据库设计**和**业务模型设计**（也就是业务逻辑）。

接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。为了兼顾易用性和性能，我们可以借鉴 **facade（外观）设计模式**，**在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。**

大部分业务系统的开发都可以分为 **Controller、Service、Repository** 三层。Controller 层负责**接口暴露**，Repository 层负责**数据读写**，Service 层负责**核心业务逻辑**。



### 为什么要分 MVC 三层开发？

1. 分层能起到代码复用的作用
2. 分层能起到隔离变化的作用
3. 分层能起到隔离关注点的作用
4. 分层能提高代码的可测试性
5. 分层能应对系统的复杂性

### BO、VO、Entity 存在的意义是什么？

Controller、Service、Repository 三层定义相应的数据对象分别是 **VO（View Object）、BO（Business Object）、Entity**，例如 UserVo、UserBo、UserEntity。

#### 相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？

推荐每层定义各自的对象。

- VO、BO、Entity 并非完全一样。
- VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。
- 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。

#### 既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？

继承，可以将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段。

#### 代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？



#### VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？



### 总结用到的设计原则和思想

![](https://static001.geekbang.org/resource/image/33/61/3332071c82182e72518143d05b8eaa61.jpg)



## 25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？



## 26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？



# 设计原则与思想：规范和重构

## 27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？



### 重构的目的：为什么要重构（why）？



### 重构的对象：到底重构什么（what）？



### 重构的时机：什么时候重构（when）？



### 重构的方法：又该如何重构（how）？



## 28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？

当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码**原有逻辑的正确性未被破坏，原有的外部可见行为未变**。

### 什么是单元测试？

**集成测试**（Integration Testing）的测试对象是**整个系统或者某个功能模块**，比如测试**用户注册、登录功能**是否正常，是一种端到端（end to end）的测试。

**单元测试**（Unit Testing）的测试对象是**类或者函数**，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。单元测试，测试的粒度更小一些。



### 为什么要写单元测试？

1. 单元测试能有效地帮你发现代码中的 bug

2. 写单元测试能帮你发现代码设计上的问题

3. 单元测试是对集成测试的有力补充

4. 写单元测试的过程本身就是代码重构的过程

5. 阅读单元测试能帮助你快速熟悉代码

6. 单元测试是 TDD 可落地执行的改进方案

   

### 如何编写单元测试？



1. 写单元测试真的是件很耗时的事情吗？
2. 对单元测试的代码质量有什么要求吗？
3. 单元测试只要覆盖率高就够了吗？
4. 写单元测试需要了解代码的实现逻辑吗？
5. 如何选择单元测试框架？



### 单元测试为何难落地执行？





## 29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？



### 什么是代码的可测试性？

所谓代码的可测试性，就是针对代码**编写单元测试的难易程度**。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。

### 编写可测试性代码的最有效手段

依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。

### 常见的 Anti-Patterns

常见的测试不友好的代码有下面这 5 种：

- 代码中包含未决行为逻辑
- 滥用可变全局变量
- 滥用静态方法
- 使用复杂的继承关系
- 高度耦合的代码





## 30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？



### “解耦”为何如此重要？



### 代码是否需要“解耦”？



### 如何给代码“解耦”？

封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。



## 31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）

设计原则和设计模式非常依赖个人经验，用不好有时候会适得其反。

编码规范大部分都简单明了，在代码细节方面，能立竿见影地改善质量。

编码规范的三个部分：**命名与注释（Naming and Comments）、代码风格（Code Style）和编程技巧（Coding Tips）**。

### 命名

**大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名**。

#### 1. 命名多长最合适？

在足够表达其含义的情况下，命名当然是越短越好。

对于作用域比较小的变量，我们可以使用相对短的命名。

#### 2. 利用上下文简化命名

#### 3. 命名要可读、可搜索

#### 4. 如何命名接口和抽象类？

### 注释

#### 1. 注释到底该写什么？
#### 2. 注释是不是越多越好？



## 32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）



### 1. 函数、类多大才合适？

函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。

### 2. 一行代码多长最合适？

最好不要超过 IDE 显示的宽度。当然，限制也不能太小，太小会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。

### 3. 善用空行分割单元块

对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。在类内部，成员变量与函数之间、静态成员变量与普通成员变量之间、函数之间，甚至成员变量之间，都可以通过添加空行的方式，让不同模块的代码之间的界限更加明确。

### 4. 四格缩进还是两格缩进？

我个人比较推荐使用两格缩进，这样可以节省空间，特别是在代码嵌套层次比较深的情况下。除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。

### 5. 大括号是否要另起一行？

我个人还是比较推荐将大括号放到跟上一条语句同一行的风格，这样可以节省代码行数。但是，将大括号另起一行，也有它的优势，那就是，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。

### 6. 类中成员的排列顺序

在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。



## 33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）

编程技巧

### 1. 把代码分割成更小的单元块



### 2. 避免函数参数过多



### 3. 勿用函数参数来控制逻辑



### 4. 函数设计要职责单一



### 5. 移除过深的嵌套层次



### 6. 学会使用解释性变量





最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定**统一的编码规范**，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。



## 34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题

