# 设计原则与思想：设计原则



## 15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？



### 如何理解单一职责原则（SRP）？

一个类只负责完成一个职责或者功能。不要设计大而全的类，要**设计粒度小、功能单一**的类。

单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

### 如何判断类的职责是否足够单一？

不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些**侧面的判断指标**更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：

- 类中的代码行数、函数或者属性过多；
- 类依赖的其他类过多，或者依赖类的其他类过多；
- 私有方法过多；
- 比较难给类起一个合适的名字；
- 类中大量的方法都是集中操作类中的某几个属性。

### 类的职责是否设计得越单一越好？



## 16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？



## 17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？

里式替换原则是用来指导，**继承关系中子类该如何设计**的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。



## 18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？





## 19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？



### 控制反转（IOC）

Inversion Of Control，“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

### 依赖注入（DI）

Dependency Injection，不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。



### 依赖注入框架（DI Framework）



### 依赖反转原则（DIP）

Dependency Inversion Principle，也称依赖倒置原则

> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。



## 20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？

### 如何理解“KISS 原则”？

**尽量保持简单**，英文有几个版本：

- Keep It Simple and Stupid.
- Keep It Short and Simple.
- Keep It Simple and Straightforward.

KISS原则应用很多场景：软件开发、系统设计、产品设计等。

### 代码行数越少就越“简单”吗？



### 代码逻辑复杂就违背 KISS 原则吗？



### 如何写出满足 KISS 原则的代码？

越是能用简单的方法解决复杂的问题，越能体现一个人的能力。

### YAGNI 跟 KISS 说的是一回事吗？

YAGNI，You Ain’t Gonna Need It，直译”**你不会需要它**“。应用到软件开发中就是：”**不要去设计当前用不到的功能；不要去编写当前用不到的代码。**“



## 21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？



### DRY 原则（Don’t Repeat Yourself）

三种典型的代码重复情况：**逻辑重复、功能语义重复和代码执行重复**。



### 代码复用性（Code Reusability）



## 22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？



### 何为“高内聚、松耦合”？

“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如**系统、模块、类，甚至是函数**，也可以应用到不同的开发场景中，比如**微服务、框架、组件、类库**等。

**高内聚**，就是指<font color=#FF8C00>**相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中**</font>。

**松耦合**，就是指<font color=#FF8C00>**类与类之间的依赖关系简单清晰**</font>。



### “迪米特法则”理论描述



## 23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？

对于一个工程师来说，如果要追求长远发展，你就不能一直只把自己放在执行者的角色，不能只是一个**代码实现者**，你还要有独立负责一个系统的能力，**能端到端（end to end）开发一个完整的系统**。这其中的工作就包括：**前期的需求沟通分析**、**中期的代码设计实现**、**后期的系统上线维护**等。

积分兑换系统



## 24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？



### 业务开发包括哪些工作？

**接口设计**、**数据库设计**和**业务模型设计**（也就是业务逻辑）。

接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。为了兼顾易用性和性能，我们可以借鉴 **facade（外观）设计模式**，**在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。**

大部分业务系统的开发都可以分为 **Controller、Service、Repository** 三层。Controller 层负责**接口暴露**，Repository 层负责**数据读写**，Service 层负责**核心业务逻辑**。



### 为什么要分 MVC 三层开发？

1. 分层能起到代码复用的作用
2. 分层能起到隔离变化的作用
3. 分层能起到隔离关注点的作用
4. 分层能提高代码的可测试性
5. 分层能应对系统的复杂性

### BO、VO、Entity 存在的意义是什么？

Controller、Service、Repository 三层定义相应的数据对象分别是 **VO（View Object）、BO（Business Object）、Entity**，例如 UserVo、UserBo、UserEntity。

#### 相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？

推荐每层定义各自的对象。

- VO、BO、Entity 并非完全一样。
- VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。
- 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。

#### 既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？

继承，可以将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段。

#### 代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？



#### VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？



### 总结用到的设计原则和思想

![](https://static001.geekbang.org/resource/image/33/61/3332071c82182e72518143d05b8eaa61.jpg)



## 25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？



## 26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？

